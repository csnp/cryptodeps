// Copyright 2024 CSNP (csnp.org)
// SPDX-License-Identifier: Apache-2.0

package output

import (
	"fmt"
	"io"

	"github.com/csnp/qramm-cryptodeps/pkg/types"
)

// MarkdownFormatter formats scan results as Markdown.
type MarkdownFormatter struct{}

// Format writes the scan result as Markdown.
func (f *MarkdownFormatter) Format(result *types.ScanResult, w io.Writer) error {
	// Title
	fmt.Fprintf(w, "# CryptoDeps Scan Report\n\n")

	// Summary
	fmt.Fprintf(w, "## Summary\n\n")
	fmt.Fprintf(w, "| Metric | Value |\n")
	fmt.Fprintf(w, "|--------|-------|\n")
	fmt.Fprintf(w, "| **Manifest** | `%s` |\n", result.Manifest)
	fmt.Fprintf(w, "| **Ecosystem** | %s |\n", result.Ecosystem)
	fmt.Fprintf(w, "| **Total Dependencies** | %d |\n", result.Summary.TotalDependencies)
	fmt.Fprintf(w, "| **Using Crypto** | %d |\n", result.Summary.WithCrypto)
	fmt.Fprintf(w, "| **Quantum Vulnerable** | %d |\n", result.Summary.QuantumVulnerable)
	fmt.Fprintf(w, "| **Quantum Partial** | %d |\n", result.Summary.QuantumPartial)
	fmt.Fprintf(w, "| **Not in Database** | %d |\n", result.Summary.NotInDatabase)
	fmt.Fprintf(w, "\n")

	// Check if there are any crypto findings
	hasCrypto := false
	for _, dep := range result.Dependencies {
		if dep.Analysis != nil && len(dep.Analysis.Crypto) > 0 {
			hasCrypto = true
			break
		}
	}

	if !hasCrypto {
		fmt.Fprintf(w, "No cryptographic usage detected in dependencies.\n")
		return nil
	}

	// Findings by risk level
	fmt.Fprintf(w, "## Findings\n\n")

	// Vulnerable
	fmt.Fprintf(w, "### Quantum Vulnerable\n\n")
	hasVulnerable := false
	for _, dep := range result.Dependencies {
		if dep.Analysis == nil {
			continue
		}
		for _, crypto := range dep.Analysis.Crypto {
			if crypto.QuantumRisk == types.RiskVulnerable {
				if !hasVulnerable {
					fmt.Fprintf(w, "| Dependency | Algorithm | Type | Severity |\n")
					fmt.Fprintf(w, "|------------|-----------|------|----------|\n")
					hasVulnerable = true
				}
				fmt.Fprintf(w, "| %s@%s | %s | %s | %s |\n",
					dep.Dependency.Name,
					dep.Dependency.Version,
					crypto.Algorithm,
					crypto.Type,
					crypto.Severity,
				)
			}
		}
	}
	if !hasVulnerable {
		fmt.Fprintf(w, "No quantum-vulnerable algorithms found.\n")
	}
	fmt.Fprintf(w, "\n")

	// Partial
	fmt.Fprintf(w, "### Quantum Partial Risk\n\n")
	hasPartial := false
	for _, dep := range result.Dependencies {
		if dep.Analysis == nil {
			continue
		}
		for _, crypto := range dep.Analysis.Crypto {
			if crypto.QuantumRisk == types.RiskPartial {
				if !hasPartial {
					fmt.Fprintf(w, "| Dependency | Algorithm | Type | Severity |\n")
					fmt.Fprintf(w, "|------------|-----------|------|----------|\n")
					hasPartial = true
				}
				fmt.Fprintf(w, "| %s@%s | %s | %s | %s |\n",
					dep.Dependency.Name,
					dep.Dependency.Version,
					crypto.Algorithm,
					crypto.Type,
					crypto.Severity,
				)
			}
		}
	}
	if !hasPartial {
		fmt.Fprintf(w, "No partial-risk algorithms found.\n")
	}
	fmt.Fprintf(w, "\n")

	// Recommendations
	fmt.Fprintf(w, "## Recommendations\n\n")
	if result.Summary.QuantumVulnerable > 0 {
		fmt.Fprintf(w, "- **Migrate quantum-vulnerable algorithms** to post-quantum alternatives (ML-KEM, ML-DSA, SLH-DSA)\n")
		fmt.Fprintf(w, "- Review dependencies using RSA, ECDSA, Ed25519, and other asymmetric algorithms\n")
	}
	if result.Summary.QuantumPartial > 0 {
		fmt.Fprintf(w, "- Consider upgrading to **256-bit symmetric keys** (AES-256, SHA-384/512) for post-quantum security\n")
	}
	fmt.Fprintf(w, "- Monitor [NIST PQC standards](https://csrc.nist.gov/projects/post-quantum-cryptography) for updates\n")
	fmt.Fprintf(w, "\n")

	// Footer
	fmt.Fprintf(w, "---\n\n")
	fmt.Fprintf(w, "*Generated by [CryptoDeps](https://github.com/csnp/qramm-cryptodeps) - Part of the [QRAMM Toolkit](https://qramm.org)*\n")

	return nil
}
